name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  release:
    types: [ published ]

# Required permissions for test reporting
permissions:
  contents: read
  actions: read
  checks: write
  pull-requests: write

env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_NOLOGO: true
  SOLUTION_FILE: 'PwrSvg.sln'

jobs:
  test:
    name: Build and Test
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        dotnet-version: ['8.0.x']
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ matrix.dotnet-version }}
    
    - name: Restore dependencies
      run: dotnet restore ${{ env.SOLUTION_FILE }}
      
    - name: Build for .NET 8.0
      run: dotnet build ${{ env.SOLUTION_FILE }} -c Release -f net8.0 --no-restore
      
    - name: Build for .NET Framework 4.8 (Windows only)
      if: matrix.os == 'windows-latest'
      run: dotnet build PwrSvg/PwrSvg.csproj -c Release -f net48 --no-restore
      
    - name: Run tests
      run: dotnet test ${{ env.SOLUTION_FILE }} --no-build -c Release --verbosity normal
      
    - name: Run Pester Integration Tests (.NET Framework 4.8 - Windows PowerShell)
      if: matrix.os == 'windows-latest'
      shell: powershell
      run: |
        Write-Host "üß™ Running Pester Integration Tests for .NET Framework 4.8" -ForegroundColor Green
        
        # Ensure Pester is available
        if (-not (Get-Module -ListAvailable Pester)) {
          Write-Host "Installing Pester module..." -ForegroundColor Yellow
          Install-Module -Name Pester -Force -SkipPublisherCheck -Scope CurrentUser
        }
        
        $pesterVersion = (Get-Module -ListAvailable Pester | Select-Object -First 1).Version
        Write-Host "Using Pester version: $pesterVersion with Windows PowerShell ($($PSVersionTable.PSVersion))" -ForegroundColor Green
        
        # Configure Pester for xUnit XML output
        $config = New-PesterConfiguration
        $config.TestResult.Enabled = $true
        $config.TestResult.OutputFormat = 'JUnitXml'
        $config.TestResult.OutputPath = 'pester-test-results-net48.xml'
        $config.Run.Path = './PwrSvg.Integration.Tests.ps1'
        $config.Output.Verbosity = 'Detailed'
        
        # Run Pester with configuration and capture results
        try {
          Write-Host "Executing Pester tests for .NET Framework 4.8..." -ForegroundColor Yellow
          $testResults = Invoke-Pester -Configuration $config
          Write-Host "Pester execution completed for .NET Framework 4.8" -ForegroundColor Yellow
          
          if ($testResults.FailedCount -gt 0) {
            Write-Host "‚ùå Pester integration tests failed: $($testResults.FailedCount) failed out of $($testResults.TotalCount) tests" -ForegroundColor Red
            # Don't exit immediately - let the test reporter process the results
          } else {
            Write-Host "‚úÖ All Pester integration tests passed: $($testResults.PassedCount)/$($testResults.TotalCount)" -ForegroundColor Green
          }
          
          # Verify test results file exists
          if (Test-Path 'pester-test-results-net48.xml') {
            Write-Host "‚úÖ Test results file generated successfully" -ForegroundColor Green
            $fileSize = (Get-Item 'pester-test-results-net48.xml').Length
            Write-Host "File size: $fileSize bytes" -ForegroundColor Yellow
          } else {
            Write-Host "‚ö†Ô∏è  Test results file not found, creating fallback results file" -ForegroundColor Yellow
            $fallbackXml = '<?xml version="1.0" encoding="utf-8"?><testsuites name="Pester" tests="0" errors="1" failures="0" time="0"><testsuite name="Pipeline Error" tests="1" errors="1" failures="0" time="0"><testcase name="Test execution failed" classname="Pipeline" time="0"><error message="Pester test execution failed - no results generated"/></testcase></testsuite></testsuites>'
            $fallbackXml | Out-File -FilePath 'pester-test-results-net48.xml' -Encoding UTF8
          }
          
          # Exit with failure code if tests failed, but after generating the report
          if ($testResults.FailedCount -gt 0) {
            exit 1
          }
        } catch {
          Write-Host "‚ùå Error running Pester tests: $($_.Exception.Message)" -ForegroundColor Red
          Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Red
          
          # Create error report for test reporter
          $errorMessage = $_.Exception.Message -replace '"', '&quot;'
          $errorXml = "<?xml version=`"1.0`" encoding=`"utf-8`"?><testsuites name=`"Pester`" tests=`"0`" errors=`"1`" failures=`"0`" time=`"0`"><testsuite name=`"Pipeline Error`" tests=`"1`" errors=`"1`" failures=`"0`" time=`"0`"><testcase name=`"Pester execution error`" classname=`"Pipeline`" time=`"0`"><error message=`"$errorMessage`"/></testcase></testsuite></testsuites>"
          $errorXml | Out-File -FilePath 'pester-test-results-net48.xml' -Encoding UTF8
          exit 1
        }

    - name: Run Pester Integration Tests (.NET 8 - PowerShell Core)
      if: matrix.os != 'windows-latest'
      shell: pwsh
      run: |
        Write-Host "üß™ Running Pester Integration Tests for .NET 8" -ForegroundColor Green
        
        # Ensure Pester is available
        if (-not (Get-Module -ListAvailable Pester)) {
          Write-Host "Installing Pester module..." -ForegroundColor Yellow
          Install-Module -Name Pester -Force -SkipPublisherCheck -Scope CurrentUser
        }
        
        $pesterVersion = (Get-Module -ListAvailable Pester | Select-Object -First 1).Version
        Write-Host "Using Pester version: $pesterVersion with PowerShell Core ($($PSVersionTable.PSVersion))" -ForegroundColor Green
        
        # Configure Pester for xUnit XML output
        $config = New-PesterConfiguration
        $config.TestResult.Enabled = $true
        $config.TestResult.OutputFormat = 'JUnitXml'
        $config.TestResult.OutputPath = 'pester-test-results-net8.xml'
        $config.Run.Path = './PwrSvg.Integration.Tests.ps1'
        $config.Output.Verbosity = 'Detailed'
        
        # Run Pester with configuration and capture results
        try {
          Write-Host "Executing Pester tests for .NET 8..." -ForegroundColor Yellow
          $testResults = Invoke-Pester -Configuration $config
          Write-Host "Pester execution completed for .NET 8" -ForegroundColor Yellow
          
          if ($testResults.FailedCount -gt 0) {
            Write-Host "‚ùå Pester integration tests failed: $($testResults.FailedCount) failed out of $($testResults.TotalCount) tests" -ForegroundColor Red
            # Don't exit immediately - let the test reporter process the results
          } else {
            Write-Host "‚úÖ All Pester integration tests passed: $($testResults.PassedCount)/$($testResults.TotalCount)" -ForegroundColor Green
          }
          
          # Verify test results file exists
          if (Test-Path 'pester-test-results-net8.xml') {
            Write-Host "‚úÖ Test results file generated successfully" -ForegroundColor Green
            $fileSize = (Get-Item 'pester-test-results-net8.xml').Length
            Write-Host "File size: $fileSize bytes" -ForegroundColor Yellow
          } else {
            Write-Host "‚ö†Ô∏è  Test results file not found, creating fallback results file" -ForegroundColor Yellow
            $fallbackXml = '<?xml version="1.0" encoding="utf-8"?><testsuites name="Pester" tests="0" errors="1" failures="0" time="0"><testsuite name="Pipeline Error" tests="1" errors="1" failures="0" time="0"><testcase name="Test execution failed" classname="Pipeline" time="0"><error message="Pester test execution failed - no results generated"/></testcase></testsuite></testsuites>'
            $fallbackXml | Out-File -FilePath 'pester-test-results-net8.xml' -Encoding UTF8
          }
          
          # Exit with failure code if tests failed, but after generating the report
          if ($testResults.FailedCount -gt 0) {
            exit 1
          }
        } catch {
          Write-Host "‚ùå Error running Pester tests: $($_.Exception.Message)" -ForegroundColor Red
          Write-Host "Stack trace: $($_.ScriptStackTrace)" -ForegroundColor Red
          
          # Create error report for test reporter
          $errorMessage = $_.Exception.Message -replace '"', '&quot;'
          $errorXml = "<?xml version=`"1.0`" encoding=`"utf-8`"?><testsuites name=`"Pester`" tests=`"0`" errors=`"1`" failures=`"0`" time=`"0`"><testsuite name=`"Pipeline Error`" tests=`"1`" errors=`"1`" failures=`"0`" time=`"0`"><testcase name=`"Pester execution error`" classname=`"Pipeline`" time=`"0`"><error message=`"$errorMessage`"/></testcase></testsuite></testsuites>"
          $errorXml | Out-File -FilePath 'pester-test-results-net8.xml' -Encoding UTF8
          exit 1
        }

    - name: Publish Pester Test Results (.NET Framework 4.8)
      uses: dorny/test-reporter@v1.9.1
      if: always() && matrix.os == 'windows-latest'  # Always run to show test results on Windows
      with:
        name: Pester Integration Tests (.NET Framework 4.8)
        path: './pester-test-results-net48.xml'
        reporter: java-junit
        fail-on-error: false  # Let the previous step handle the failure
        max-annotations: 10

    - name: Publish Pester Test Results (.NET 8)
      uses: dorny/test-reporter@v1.9.1
      if: always() && matrix.os != 'windows-latest'  # Always run to show test results on Unix
      with:
        name: Pester Integration Tests (.NET 8)
        path: './pester-test-results-net8.xml'
        reporter: java-junit
        fail-on-error: false  # Let the previous step handle the failure
        max-annotations: 10
      
    - name: Test PowerShell module import (.NET 8.0 - Cross-Platform)
      shell: pwsh
      run: |
        dotnet publish PwrSvg/PwrSvg.csproj -c Release -f net8.0 -o ./publish-net8
        Import-Module ./publish-net8/PwrSvg.dll -Force
        Get-Command -Module PwrSvg
        
        Write-Host "üß™ Testing .NET 8.0 on ${{ matrix.os }} with PowerShell Core"
        
        # Test ConvertTo-Png functionality with test SVG
        $result = ConvertTo-Png -Path ./test.svg -Verbose
        if ($null -eq $result) {
          throw "ConvertTo-Png returned null result"
        }
        if ($result.Length -eq 0) {
          throw "ConvertTo-Png returned empty result"
        }
        Write-Host "‚úÖ .NET 8.0 (${{ matrix.os }}): ConvertTo-Png successfully converted test.svg to PNG ($($result.Length) bytes)"
        
        # Test ConvertTo-Png with file output
        ConvertTo-Png -Path ./test.svg -OutFile ./test-output-net8-${{ matrix.os }}.png -Verbose
        if (-not (Test-Path ./test-output-net8-${{ matrix.os }}.png)) {
          throw "ConvertTo-Png failed to create output file"
        }
        $fileSize = (Get-Item ./test-output-net8-${{ matrix.os }}.png).Length
        if ($fileSize -eq 0) {
          throw "ConvertTo-Png created empty output file"
        }
        Write-Host "‚úÖ .NET 8.0 (${{ matrix.os }}): ConvertTo-Png successfully created output file ($fileSize bytes)"
        
    - name: Test PowerShell module import (.NET Framework 4.8 - Windows Only)
      if: matrix.os == 'windows-latest'
      run: |
        dotnet publish PwrSvg/PwrSvg.csproj -c Release -f net48 -o ./publish-net48
        
        Write-Host "üß™ Testing .NET Framework 4.8 on Windows with multiple PowerShell versions"
        
        # Test with Windows PowerShell (powershell.exe) - Memory Stream Output
        powershell -Command "Import-Module ./publish-net48/PwrSvg.dll -Force; Get-Command -Module PwrSvg; `$result = ConvertTo-Png -Path ./test.svg -Verbose; if (`$null -eq `$result) { throw 'ConvertTo-Png returned null result' }; if (`$result.Length -eq 0) { throw 'ConvertTo-Png returned empty result' }; Write-Host '‚úÖ .NET Framework 4.8 (Windows PowerShell): ConvertTo-Png successfully converted test.svg to PNG (' `$result.Length ' bytes)'"
        
        # Test with Windows PowerShell (powershell.exe) - File Output
        powershell -Command "Import-Module ./publish-net48/PwrSvg.dll -Force; ConvertTo-Png -Path ./test.svg -OutFile ./test-output-net48-winps.png -Verbose; if (-not (Test-Path ./test-output-net48-winps.png)) { throw 'ConvertTo-Png failed to create output file' }; `$fileSize = (Get-Item ./test-output-net48-winps.png).Length; if (`$fileSize -eq 0) { throw 'ConvertTo-Png created empty output file' }; Write-Host '‚úÖ .NET Framework 4.8 (Windows PowerShell): ConvertTo-Png successfully created output file (' `$fileSize ' bytes)'"
        
        # Test with PowerShell Core (pwsh.exe) - Memory Stream Output  
        pwsh -Command "Import-Module ./publish-net48/PwrSvg.dll -Force; Get-Command -Module PwrSvg; `$result = ConvertTo-Png -Path ./test.svg -Verbose; if (`$null -eq `$result) { throw 'ConvertTo-Png returned null result' }; if (`$result.Length -eq 0) { throw 'ConvertTo-Png returned empty result' }; Write-Host '‚úÖ .NET Framework 4.8 (PowerShell Core): ConvertTo-Png successfully converted test.svg to PNG (' `$result.Length ' bytes)'"
        
        # Test with PowerShell Core (pwsh.exe) - File Output
        pwsh -Command "Import-Module ./publish-net48/PwrSvg.dll -Force; ConvertTo-Png -Path ./test.svg -OutFile ./test-output-net48-pwsh.png -Verbose; if (-not (Test-Path ./test-output-net48-pwsh.png)) { throw 'ConvertTo-Png failed to create output file' }; `$fileSize = (Get-Item ./test-output-net48-pwsh.png).Length; if (`$fileSize -eq 0) { throw 'ConvertTo-Png created empty output file' }; Write-Host '‚úÖ .NET Framework 4.8 (PowerShell Core): ConvertTo-Png successfully created output file (' `$fileSize ' bytes)'"

  package:
    name: Create Packages
    needs: test
    runs-on: windows-latest
    if: github.event_name == 'release'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'
    
    - name: Restore dependencies
      run: dotnet restore ${{ env.SOLUTION_FILE }}
      
    - name: Create Unified PowerShell Gallery Package Structure
      shell: pwsh  
      run: |
        $version = '${{ github.event.release.tag_name }}' -replace '^v', ''
        
        # Create unified module package structure with subdirectories for each .NET version
        # This allows a single .psd1 manifest to dynamically load the correct assembly
        $moduleDir = "./PowerShellGallery/PwrSvg"
        New-Item -ItemType Directory -Path $moduleDir -Force
        New-Item -ItemType Directory -Path "$moduleDir/net8" -Force  
        New-Item -ItemType Directory -Path "$moduleDir/net48" -Force
        
        # Copy the unified manifest that uses $PSEdition to select the correct assembly
        Copy-Item "PwrSvg/PwrSvg.psd1" $moduleDir
        
        # Copy PowerShell script files to the root of the module
        Copy-Item "PwrSvg/Out-ConsoleSvg.ps1" $moduleDir
        
        # Update manifest version from release tag
        $manifestPath = "$moduleDir/PwrSvg.psd1"
        (Get-Content $manifestPath) -replace "ModuleVersion = '[^']*'", "ModuleVersion = '$version'" | Set-Content $manifestPath
        
    - name: Build and Publish .NET 8.0 Directly to Package
      run: |
        dotnet publish PwrSvg/PwrSvg.csproj -c Release -f net8.0 -o ./PowerShellGallery/PwrSvg/net8
      shell: pwsh
      
    - name: Build and Publish .NET Framework 4.8 Directly to Package
      run: |
        dotnet publish PwrSvg/PwrSvg.csproj -c Release -f net48 -o ./PowerShellGallery/PwrSvg/net48
      shell: pwsh
        
    - name: Upload Unified PowerShell Gallery Package
      uses: actions/upload-artifact@v4
      with:
        name: PwrSvg-PSGallery
        path: ./PowerShellGallery/

  publish:
    name: Publish to PowerShell Gallery
    needs: package
    runs-on: windows-latest
    if: github.event_name == 'release'
    
    steps:
    - name: Download PowerShell Gallery Package
      uses: actions/download-artifact@v4
      with:
        name: PwrSvg-PSGallery
        path: ./
        
    - name: Publish to PowerShell Gallery
      shell: pwsh
      run: |
        $apiKey = "${{ secrets.POWERSHELL_GALLERY_API_KEY }}"
        if ([string]::IsNullOrEmpty($apiKey)) {
          Write-Error "PowerShell Gallery API key not found in secrets. Please add POWERSHELL_GALLERY_API_KEY to repository secrets."
          exit 1
        }
        
        # Install required modules
        Install-Module -Name PowerShellGet -Force -AllowClobber -Scope CurrentUser
        
        # Publish module
        try {
          Publish-Module -Path "./PwrSvg" -NuGetApiKey $apiKey -Verbose -Force
          Write-Host "‚úÖ Successfully published PwrSvg module to PowerShell Gallery"
        } catch {
          Write-Error "‚ùå Failed to publish to PowerShell Gallery: $_"
          exit 1
        }