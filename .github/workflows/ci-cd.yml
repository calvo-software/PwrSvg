name: CI/CD Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  release:
    types: [ published ]

env:
  DOTNET_SKIP_FIRST_TIME_EXPERIENCE: true
  DOTNET_NOLOGO: true
  SOLUTION_FILE: 'PwrSvg.sln'

jobs:
  test:
    name: Build and Test
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]
        dotnet-version: ['8.0.x']
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{ matrix.dotnet-version }}
    
    - name: Restore dependencies
      run: dotnet restore ${{ env.SOLUTION_FILE }}
      
    - name: Build for .NET 8.0
      run: dotnet build ${{ env.SOLUTION_FILE }} -c Release -f net8.0 --no-restore
      
    - name: Build for .NET Framework 4.8 (Windows only)
      if: matrix.os == 'windows-latest'
      run: dotnet build PwrSvg/PwrSvg.csproj -c Release -f net48 --no-restore
      
    - name: Run tests
      run: dotnet test ${{ env.SOLUTION_FILE }} --no-build -c Release --verbosity normal
      
    - name: Run Pester Integration Tests
      shell: pwsh
      run: |
        Write-Host "üß™ Running Pester Integration Tests" -ForegroundColor Green
        
        # Configure Pester for xUnit XML output
        $config = New-PesterConfiguration
        $config.TestResult.Enabled = $true
        $config.TestResult.OutputFormat = 'JUnitXml'
        $config.TestResult.OutputPath = 'pester-test-results.xml'
        $config.Run.Path = './PwrSvg.Integration.Tests.ps1'
        $config.Output.Verbosity = 'Detailed'
        
        # Run Pester with configuration
        $testResults = Invoke-Pester -Configuration $config
        
        if ($testResults.FailedCount -gt 0) {
          Write-Host "‚ùå Pester integration tests failed: $($testResults.FailedCount) failed out of $($testResults.TotalCount) tests" -ForegroundColor Red
          exit 1
        }
        Write-Host "‚úÖ All Pester integration tests passed: $($testResults.PassedCount)/$($testResults.TotalCount)" -ForegroundColor Green

    - name: Publish Pester Test Results
      uses: dorny/test-reporter@v1
      if: success() || failure()  # Run even if tests failed
      with:
        name: Pester Integration Tests
        path: pester-test-results.xml
        reporter: java-junit
        fail-on-error: true
      
    - name: Test PowerShell module import (.NET 8.0 - Cross-Platform)
      shell: pwsh
      run: |
        dotnet publish PwrSvg/PwrSvg.csproj -c Release -f net8.0 -o ./publish-net8
        Import-Module ./publish-net8/PwrSvg.dll -Force
        Get-Command -Module PwrSvg
        
        Write-Host "üß™ Testing .NET 8.0 on ${{ matrix.os }} with PowerShell Core"
        
        # Test ConvertTo-Png functionality with test SVG
        $result = ConvertTo-Png -Path ./test.svg -Verbose
        if ($null -eq $result) {
          throw "ConvertTo-Png returned null result"
        }
        if ($result.Length -eq 0) {
          throw "ConvertTo-Png returned empty result"
        }
        Write-Host "‚úÖ .NET 8.0 (${{ matrix.os }}): ConvertTo-Png successfully converted test.svg to PNG ($($result.Length) bytes)"
        
        # Test ConvertTo-Png with file output
        ConvertTo-Png -Path ./test.svg -OutFile ./test-output-net8-${{ matrix.os }}.png -Verbose
        if (-not (Test-Path ./test-output-net8-${{ matrix.os }}.png)) {
          throw "ConvertTo-Png failed to create output file"
        }
        $fileSize = (Get-Item ./test-output-net8-${{ matrix.os }}.png).Length
        if ($fileSize -eq 0) {
          throw "ConvertTo-Png created empty output file"
        }
        Write-Host "‚úÖ .NET 8.0 (${{ matrix.os }}): ConvertTo-Png successfully created output file ($fileSize bytes)"
        
    - name: Test PowerShell module import (.NET Framework 4.8 - Windows Only)
      if: matrix.os == 'windows-latest'
      run: |
        dotnet publish PwrSvg/PwrSvg.csproj -c Release -f net48 -o ./publish-net48
        
        Write-Host "üß™ Testing .NET Framework 4.8 on Windows with multiple PowerShell versions"
        
        # Test with Windows PowerShell (powershell.exe) - Memory Stream Output
        powershell -Command "Import-Module ./publish-net48/PwrSvg.dll -Force; Get-Command -Module PwrSvg; `$result = ConvertTo-Png -Path ./test.svg -Verbose; if (`$null -eq `$result) { throw 'ConvertTo-Png returned null result' }; if (`$result.Length -eq 0) { throw 'ConvertTo-Png returned empty result' }; Write-Host '‚úÖ .NET Framework 4.8 (Windows PowerShell): ConvertTo-Png successfully converted test.svg to PNG (' `$result.Length ' bytes)'"
        
        # Test with Windows PowerShell (powershell.exe) - File Output
        powershell -Command "Import-Module ./publish-net48/PwrSvg.dll -Force; ConvertTo-Png -Path ./test.svg -OutFile ./test-output-net48-winps.png -Verbose; if (-not (Test-Path ./test-output-net48-winps.png)) { throw 'ConvertTo-Png failed to create output file' }; `$fileSize = (Get-Item ./test-output-net48-winps.png).Length; if (`$fileSize -eq 0) { throw 'ConvertTo-Png created empty output file' }; Write-Host '‚úÖ .NET Framework 4.8 (Windows PowerShell): ConvertTo-Png successfully created output file (' `$fileSize ' bytes)'"
        
        # Test with PowerShell Core (pwsh.exe) - Memory Stream Output  
        pwsh -Command "Import-Module ./publish-net48/PwrSvg.dll -Force; Get-Command -Module PwrSvg; `$result = ConvertTo-Png -Path ./test.svg -Verbose; if (`$null -eq `$result) { throw 'ConvertTo-Png returned null result' }; if (`$result.Length -eq 0) { throw 'ConvertTo-Png returned empty result' }; Write-Host '‚úÖ .NET Framework 4.8 (PowerShell Core): ConvertTo-Png successfully converted test.svg to PNG (' `$result.Length ' bytes)'"
        
        # Test with PowerShell Core (pwsh.exe) - File Output
        pwsh -Command "Import-Module ./publish-net48/PwrSvg.dll -Force; ConvertTo-Png -Path ./test.svg -OutFile ./test-output-net48-pwsh.png -Verbose; if (-not (Test-Path ./test-output-net48-pwsh.png)) { throw 'ConvertTo-Png failed to create output file' }; `$fileSize = (Get-Item ./test-output-net48-pwsh.png).Length; if (`$fileSize -eq 0) { throw 'ConvertTo-Png created empty output file' }; Write-Host '‚úÖ .NET Framework 4.8 (PowerShell Core): ConvertTo-Png successfully created output file (' `$fileSize ' bytes)'"

  package:
    name: Create Packages
    needs: test
    runs-on: windows-latest
    if: github.event_name == 'release'
    
    steps:
    - uses: actions/checkout@v4
    
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: '8.0.x'
    
    - name: Restore dependencies
      run: dotnet restore ${{ env.SOLUTION_FILE }}
      
    - name: Create Unified PowerShell Gallery Package Structure
      shell: pwsh  
      run: |
        $version = '${{ github.event.release.tag_name }}' -replace '^v', ''
        
        # Create unified module package structure with subdirectories for each .NET version
        # This allows a single .psd1 manifest to dynamically load the correct assembly
        $moduleDir = "./PowerShellGallery/PwrSvg"
        New-Item -ItemType Directory -Path $moduleDir -Force
        New-Item -ItemType Directory -Path "$moduleDir/net8" -Force  
        New-Item -ItemType Directory -Path "$moduleDir/net48" -Force
        
        # Copy the unified manifest that uses $PSEdition to select the correct assembly
        Copy-Item "PwrSvg/PwrSvg.psd1" $moduleDir
        
        # Copy PowerShell script files to the root of the module
        Copy-Item "PwrSvg/Out-ConsoleSvg.ps1" $moduleDir
        
        # Update manifest version from release tag
        $manifestPath = "$moduleDir/PwrSvg.psd1"
        (Get-Content $manifestPath) -replace "ModuleVersion = '[^']*'", "ModuleVersion = '$version'" | Set-Content $manifestPath
        
    - name: Build and Publish .NET 8.0 Directly to Package
      run: |
        dotnet publish PwrSvg/PwrSvg.csproj -c Release -f net8.0 -o ./PowerShellGallery/PwrSvg/net8
      shell: pwsh
      
    - name: Build and Publish .NET Framework 4.8 Directly to Package
      run: |
        dotnet publish PwrSvg/PwrSvg.csproj -c Release -f net48 -o ./PowerShellGallery/PwrSvg/net48
      shell: pwsh
        
    - name: Upload Unified PowerShell Gallery Package
      uses: actions/upload-artifact@v4
      with:
        name: PwrSvg-PSGallery
        path: ./PowerShellGallery/

  publish:
    name: Publish to PowerShell Gallery
    needs: package
    runs-on: windows-latest
    if: github.event_name == 'release'
    
    steps:
    - name: Download PowerShell Gallery Package
      uses: actions/download-artifact@v4
      with:
        name: PwrSvg-PSGallery
        path: ./
        
    - name: Publish to PowerShell Gallery
      shell: pwsh
      run: |
        $apiKey = "${{ secrets.POWERSHELL_GALLERY_API_KEY }}"
        if ([string]::IsNullOrEmpty($apiKey)) {
          Write-Error "PowerShell Gallery API key not found in secrets. Please add POWERSHELL_GALLERY_API_KEY to repository secrets."
          exit 1
        }
        
        # Install required modules
        Install-Module -Name PowerShellGet -Force -AllowClobber -Scope CurrentUser
        
        # Publish module
        try {
          Publish-Module -Path "./PwrSvg" -NuGetApiKey $apiKey -Verbose -Force
          Write-Host "‚úÖ Successfully published PwrSvg module to PowerShell Gallery"
        } catch {
          Write-Error "‚ùå Failed to publish to PowerShell Gallery: $_"
          exit 1
        }